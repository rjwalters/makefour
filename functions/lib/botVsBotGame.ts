/**
 * Shared bot vs bot game logic
 *
 * This module contains the core game advancement, rating updates, and game creation
 * logic used by both the tick endpoint and individual game endpoints.
 */

import {
  replayMoves,
  makeMove,
  createGameState,
  type Player,
} from './game'
import { calculateNewRating, type GameOutcome } from './elo'
import {
  suggestMoveWithEngine,
  calculateTimeBudget,
  type DifficultyLevel,
  type BotPersonaConfig,
} from './bot'
import type { EngineType } from './ai-engine'
import {
  getRandomReaction,
  shouldBotSpeak,
  type ChatPersonality,
  type ReactionType,
} from './botPersonas'
import { createDb } from '../../shared/db/client'
import { users, activeGames, botPersonas, games, ratingHistory, gameMessages } from '../../shared/db/schema'
import { eq, and, lte, sql, desc } from 'drizzle-orm'

// Maximum games to process per tick/run
export const MAX_GAMES_PER_TICK = 10

// Target number of active bot games
export const TARGET_ACTIVE_GAMES = 3

export interface ActiveGameRow {
  id: string
  player1_id: string
  player2_id: string
  moves: string
  current_turn: number
  status: string
  winner: string | null
  player1_rating: number
  player2_rating: number
  player1_time_ms: number | null
  player2_time_ms: number | null
  turn_started_at: number | null
  bot1_persona_id: string | null
  bot2_persona_id: string | null
  move_delay_ms: number | null
  next_move_at: number | null
}

export interface BotPersonaRow {
  id: string
  name: string
  current_elo: number
  ai_engine: string
  ai_config: string
  chat_personality: string
}

export interface AdvanceGameResult {
  gameId: string
  status: 'advanced' | 'completed' | 'error'
  move?: number
  winner?: string | null
  error?: string
  chatMessage?: string | null
}

/**
 * Parse chat personality, handling both old and new formats
 */
export function parseChatPersonality(json: string): ChatPersonality | null {
  try {
    const parsed = JSON.parse(json)
    // Check if it has the required fields for ChatPersonality
    if (parsed.reactions && typeof parsed.chattiness === 'number') {
      return parsed as ChatPersonality
    }
    return null
  } catch {
    return null
  }
}

/**
 * Advance a single bot vs bot game by making the next move
 */
export async function advanceGame(
  DB: D1Database,
  game: ActiveGameRow,
  now: number
): Promise<AdvanceGameResult> {
  const db = createDb(DB)

  // Get the current bot's persona
  const currentBotPersonaId = game.current_turn === 1
    ? game.bot1_persona_id
    : game.bot2_persona_id

  if (!currentBotPersonaId) {
    return {
      gameId: game.id,
      status: 'error',
      error: 'Missing bot persona configuration',
    }
  }

  const persona = await db.query.botPersonas.findFirst({
    where: eq(botPersonas.id, currentBotPersonaId),
    columns: {
      id: true,
      name: true,
      currentElo: true,
      aiEngine: true,
      aiConfig: true,
      chatPersonality: true,
    },
  })

  if (!persona) {
    return {
      gameId: game.id,
      status: 'error',
      error: 'Bot persona not found',
    }
  }

  const chatPersonality = parseChatPersonality(persona.chatPersonality)

  // Reconstruct the current board state
  const moves = JSON.parse(game.moves) as number[]
  const currentState = moves.length > 0 ? replayMoves(moves) : createGameState()

  if (!currentState) {
    return {
      gameId: game.id,
      status: 'error',
      error: 'Invalid game state',
    }
  }

  // Calculate time budget for the bot
  const botTimeRemaining = game.current_turn === 1 ? game.player1_time_ms : game.player2_time_ms
  let player1Time = game.player1_time_ms
  let player2Time = game.player2_time_ms

  // Map persona rating to difficulty level
  const difficulty: DifficultyLevel =
    persona.currentElo < 900 ? 'beginner' :
    persona.currentElo < 1300 ? 'intermediate' :
    persona.currentElo < 1700 ? 'expert' : 'perfect'

  const timeBudget = calculateTimeBudget(botTimeRemaining ?? 60000, moves.length, difficulty)
  const startTime = Date.now()

  // Get bot's move using the engine
  const botPersonaConfig: BotPersonaConfig = {
    difficulty,
    engine: (persona.aiEngine || 'minimax') as EngineType,
  }

  const moveResult = await suggestMoveWithEngine(
    currentState.board,
    game.current_turn as Player,
    botPersonaConfig,
    timeBudget
  )

  const elapsedMs = Date.now() - startTime

  // Deduct time from current player
  if (game.current_turn === 1 && player1Time !== null) {
    player1Time = Math.max(0, player1Time - elapsedMs)
  } else if (game.current_turn === 2 && player2Time !== null) {
    player2Time = Math.max(0, player2Time - elapsedMs)
  }

  // Apply the move
  const afterMove = makeMove(currentState, moveResult.column)
  if (!afterMove) {
    return {
      gameId: game.id,
      status: 'error',
      error: 'Invalid move generated by bot',
    }
  }

  const newMoves = [...moves, moveResult.column]
  let newStatus = 'active'
  let winner: string | null = null
  const nextTurn = game.current_turn === 1 ? 2 : 1

  // Check for game over
  if (afterMove.winner !== null) {
    newStatus = 'completed'
    winner = afterMove.winner === 'draw' ? 'draw' : String(afterMove.winner)
  }

  // Calculate next move time
  const nextMoveAt = newStatus === 'active' ? now + (game.move_delay_ms ?? 2000) : null

  // Update the game
  await db.update(activeGames)
    .set({
      moves: JSON.stringify(newMoves),
      currentTurn: nextTurn,
      status: newStatus,
      winner,
      lastMoveAt: now,
      updatedAt: now,
      player1TimeMs: player1Time,
      player2TimeMs: player2Time,
      turnStartedAt: newStatus === 'active' ? now : game.turn_started_at,
      nextMoveAt,
    })
    .where(eq(activeGames.id, game.id))

  // Generate bot chat message if appropriate
  let chatMessage: string | null = null
  if (chatPersonality && shouldBotSpeak(chatPersonality.chattiness)) {
    let reactionType: ReactionType = 'gameStart'

    if (newMoves.length === 1) {
      reactionType = 'gameStart'
    } else if (newStatus === 'completed') {
      if (winner === 'draw') {
        reactionType = 'draw'
      } else if (winner === String(game.current_turn)) {
        reactionType = 'gameWon'
      } else {
        reactionType = 'gameLost'
      }
    } else {
      const evalScore = moveResult.score ?? 0
      if (evalScore > 500) {
        reactionType = 'botWinning'
      } else if (evalScore < -500) {
        reactionType = 'botLosing'
      }
    }

    chatMessage = getRandomReaction(chatPersonality, reactionType)

    if (chatMessage) {
      const messageId = crypto.randomUUID()
      const botUserId = game.current_turn === 1 ? game.player1_id : game.player2_id

      await db.insert(gameMessages).values({
        id: messageId,
        gameId: game.id,
        senderId: botUserId,
        senderType: 'bot',
        content: chatMessage,
        createdAt: now,
      })
    }
  }

  // Update ratings if game is complete
  if (newStatus === 'completed') {
    await updateBotRatings(db, game, winner, now)
  }

  return {
    gameId: game.id,
    status: newStatus === 'completed' ? 'completed' : 'advanced',
    move: moveResult.column,
    winner,
    chatMessage,
  }
}

/**
 * Update both bots' ratings after a bot vs bot game
 */
export async function updateBotRatings(
  db: ReturnType<typeof createDb>,
  game: ActiveGameRow,
  winner: string | null,
  now: number
): Promise<void> {
  const moves = JSON.parse(game.moves) as number[]

  let bot1Outcome: GameOutcome
  let bot2Outcome: GameOutcome

  if (winner === 'draw') {
    bot1Outcome = 'draw'
    bot2Outcome = 'draw'
  } else if (winner === '1') {
    bot1Outcome = 'win'
    bot2Outcome = 'loss'
  } else {
    bot1Outcome = 'loss'
    bot2Outcome = 'win'
  }

  const [bot1User, bot2User] = await Promise.all([
    db.query.users.findFirst({
      where: and(eq(users.id, game.player1_id), eq(users.isBot, 1)),
      columns: {
        rating: true,
        gamesPlayed: true,
        wins: true,
        losses: true,
        draws: true,
      },
    }),
    db.query.users.findFirst({
      where: and(eq(users.id, game.player2_id), eq(users.isBot, 1)),
      columns: {
        rating: true,
        gamesPlayed: true,
        wins: true,
        losses: true,
        draws: true,
      },
    }),
  ])

  if (bot1User) {
    const bot1Result = calculateNewRating(
      game.player1_rating,
      game.player2_rating,
      bot1Outcome,
      bot1User.gamesPlayed
    )

    const bot1GameId = crypto.randomUUID()
    const bot1RatingHistoryId = crypto.randomUUID()

    await db.insert(games).values({
      id: bot1GameId,
      userId: game.player1_id,
      outcome: bot1Outcome,
      moves: JSON.stringify(moves),
      moveCount: moves.length,
      ratingChange: bot1Result.ratingChange,
      opponentType: 'ai',
      opponentId: game.player2_id,
      playerNumber: 1,
      createdAt: now,
    })

    await db.update(users)
      .set({
        rating: bot1Result.newRating,
        gamesPlayed: bot1User.gamesPlayed + 1,
        wins: bot1User.wins + (bot1Outcome === 'win' ? 1 : 0),
        losses: bot1User.losses + (bot1Outcome === 'loss' ? 1 : 0),
        draws: bot1User.draws + (bot1Outcome === 'draw' ? 1 : 0),
        updatedAt: now,
      })
      .where(and(eq(users.id, game.player1_id), eq(users.isBot, 1)))

    await db.insert(ratingHistory).values({
      id: bot1RatingHistoryId,
      userId: game.player1_id,
      gameId: bot1GameId,
      ratingBefore: game.player1_rating,
      ratingAfter: bot1Result.newRating,
      ratingChange: bot1Result.ratingChange,
      createdAt: now,
    })

    if (game.bot1_persona_id) {
      const bot1Persona = await db.query.botPersonas.findFirst({
        where: eq(botPersonas.id, game.bot1_persona_id),
        columns: {
          gamesPlayed: true,
          wins: true,
          losses: true,
          draws: true,
        },
      })

      if (bot1Persona) {
        await db.update(botPersonas)
          .set({
            currentElo: bot1Result.newRating,
            gamesPlayed: bot1Persona.gamesPlayed + 1,
            wins: bot1Persona.wins + (bot1Outcome === 'win' ? 1 : 0),
            losses: bot1Persona.losses + (bot1Outcome === 'loss' ? 1 : 0),
            draws: bot1Persona.draws + (bot1Outcome === 'draw' ? 1 : 0),
            updatedAt: now,
          })
          .where(eq(botPersonas.id, game.bot1_persona_id))
      }
    }
  }

  if (bot2User) {
    const bot2Result = calculateNewRating(
      game.player2_rating,
      game.player1_rating,
      bot2Outcome,
      bot2User.gamesPlayed
    )

    const bot2GameId = crypto.randomUUID()
    const bot2RatingHistoryId = crypto.randomUUID()

    await db.insert(games).values({
      id: bot2GameId,
      userId: game.player2_id,
      outcome: bot2Outcome,
      moves: JSON.stringify(moves),
      moveCount: moves.length,
      ratingChange: bot2Result.ratingChange,
      opponentType: 'ai',
      opponentId: game.player1_id,
      playerNumber: 2,
      createdAt: now,
    })

    await db.update(users)
      .set({
        rating: bot2Result.newRating,
        gamesPlayed: bot2User.gamesPlayed + 1,
        wins: bot2User.wins + (bot2Outcome === 'win' ? 1 : 0),
        losses: bot2User.losses + (bot2Outcome === 'loss' ? 1 : 0),
        draws: bot2User.draws + (bot2Outcome === 'draw' ? 1 : 0),
        updatedAt: now,
      })
      .where(and(eq(users.id, game.player2_id), eq(users.isBot, 1)))

    await db.insert(ratingHistory).values({
      id: bot2RatingHistoryId,
      userId: game.player2_id,
      gameId: bot2GameId,
      ratingBefore: game.player2_rating,
      ratingAfter: bot2Result.newRating,
      ratingChange: bot2Result.ratingChange,
      createdAt: now,
    })

    if (game.bot2_persona_id) {
      const bot2Persona = await db.query.botPersonas.findFirst({
        where: eq(botPersonas.id, game.bot2_persona_id),
        columns: {
          gamesPlayed: true,
          wins: true,
          losses: true,
          draws: true,
        },
      })

      if (bot2Persona) {
        await db.update(botPersonas)
          .set({
            currentElo: bot2Result.newRating,
            gamesPlayed: bot2Persona.gamesPlayed + 1,
            wins: bot2Persona.wins + (bot2Outcome === 'win' ? 1 : 0),
            losses: bot2Persona.losses + (bot2Outcome === 'loss' ? 1 : 0),
            draws: bot2Persona.draws + (bot2Outcome === 'draw' ? 1 : 0),
            updatedAt: now,
          })
          .where(eq(botPersonas.id, game.bot2_persona_id))
      }
    }
  }
}

/**
 * Create random bot vs bot games for entertainment
 */
export async function createRandomBotGames(
  DB: D1Database,
  count: number,
  now: number
): Promise<string[]> {
  const db = createDb(DB)

  // Get active bot personas
  const personas = await db.select({
    id: botPersonas.id,
    name: botPersonas.name,
    currentElo: botPersonas.currentElo,
  })
  .from(botPersonas)
  .where(eq(botPersonas.isActive, 1))
  .orderBy(sql`RANDOM()`)
  .limit(count * 2 + 4)

  if (personas.length < 2) {
    return []
  }

  const createdGameIds: string[] = []
  const usedPersonas = new Set<string>()

  for (let i = 0; i < count && usedPersonas.size < personas.length - 1; i++) {
    // Find two personas that haven't been used and have similar ratings
    const availablePersonas = personas.filter(p => !usedPersonas.has(p.id))

    if (availablePersonas.length < 2) break

    // Sort by rating and pick adjacent ones for more interesting matches
    availablePersonas.sort((a, b) => a.currentElo - b.currentElo)

    // Pick a random index and get that persona and the next one
    const idx = Math.floor(Math.random() * (availablePersonas.length - 1))
    const bot1 = availablePersonas[idx]
    const bot2 = availablePersonas[idx + 1]

    usedPersonas.add(bot1.id)
    usedPersonas.add(bot2.id)

    const bot1UserId = `bot_${bot1.id}`
    const bot2UserId = `bot_${bot2.id}`

    // Get actual ratings from users table
    const [bot1User, bot2User] = await Promise.all([
      db.query.users.findFirst({
        where: and(eq(users.id, bot1UserId), eq(users.isBot, 1)),
        columns: {
          rating: true,
        },
      }),
      db.query.users.findFirst({
        where: and(eq(users.id, bot2UserId), eq(users.isBot, 1)),
        columns: {
          rating: true,
        },
      }),
    ])

    const bot1Rating = bot1User?.rating ?? bot1.currentElo
    const bot2Rating = bot2User?.rating ?? bot2.currentElo

    const gameId = crypto.randomUUID()
    const moveDelayMs = 2000 + Math.floor(Math.random() * 1000) // 2-3 seconds

    await db.insert(activeGames).values({
      id: gameId,
      player1Id: bot1UserId,
      player2Id: bot2UserId,
      moves: '[]',
      currentTurn: 1,
      status: 'active',
      mode: 'ranked',
      player1Rating: bot1Rating,
      player2Rating: bot2Rating,
      spectatable: 1,
      spectatorCount: 0,
      lastMoveAt: now,
      timeControlMs: 120000,
      player1TimeMs: 120000,
      player2TimeMs: 120000,
      turnStartedAt: now,
      isBotGame: 1,
      isBotVsBot: 1,
      bot1PersonaId: bot1.id,
      bot2PersonaId: bot2.id,
      moveDelayMs,
      nextMoveAt: now + moveDelayMs,
      createdAt: now,
      updatedAt: now,
    })

    createdGameIds.push(gameId)
  }

  return createdGameIds
}

/**
 * Find active bot vs bot games ready for their next move
 */
export async function findReadyGames(
  DB: D1Database,
  now: number,
  limit: number = MAX_GAMES_PER_TICK
): Promise<ActiveGameRow[]> {
  const db = createDb(DB)

  const readyGames = await db.select({
    id: activeGames.id,
    player1_id: activeGames.player1Id,
    player2_id: activeGames.player2Id,
    moves: activeGames.moves,
    current_turn: activeGames.currentTurn,
    status: activeGames.status,
    winner: activeGames.winner,
    player1_rating: activeGames.player1Rating,
    player2_rating: activeGames.player2Rating,
    player1_time_ms: activeGames.player1TimeMs,
    player2_time_ms: activeGames.player2TimeMs,
    turn_started_at: activeGames.turnStartedAt,
    bot1_persona_id: activeGames.bot1PersonaId,
    bot2_persona_id: activeGames.bot2PersonaId,
    move_delay_ms: activeGames.moveDelayMs,
    next_move_at: activeGames.nextMoveAt,
  })
  .from(activeGames)
  .where(
    and(
      eq(activeGames.isBotVsBot, 1),
      eq(activeGames.status, 'active'),
      sql`(${activeGames.nextMoveAt} IS NULL OR ${activeGames.nextMoveAt} <= ${now})`
    )
  )
  .orderBy(activeGames.nextMoveAt)
  .limit(limit)

  return readyGames as ActiveGameRow[]
}

/**
 * Get count of active bot vs bot games
 */
export async function getActiveBotGameCount(DB: D1Database): Promise<number> {
  const db = createDb(DB)

  const result = await db.select({
    count: sql<number>`COUNT(*)`,
  })
  .from(activeGames)
  .where(and(eq(activeGames.isBotVsBot, 1), eq(activeGames.status, 'active')))
  .then(rows => rows[0])

  return result?.count ?? 0
}
